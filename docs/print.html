<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PureScript For JavaScript Developers</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PureScript For JavaScript Developers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="purescript-for-javascript-developers-a-supplementary-guide"><a class="header" href="#purescript-for-javascript-developers-a-supplementary-guide">PureScript For JavaScript Developers: A Supplementary Guide</a></h1>
<p>Unlock PureScript’s type classes with PureScript Type Classes for JavaScript Developers, a concise guide that bridges JavaScript patterns to PureScript’s powerful type system. Designed as a companion to PureScript by Example (chapters 6–8), this booklet makes type classes intuitive through JavaScript-inspired explanations and hands-on examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-this-booklet"><a class="header" href="#how-to-use-this-booklet">How To Use This Booklet</a></h1>
<p><strong>PureScript for JavaScript Developers</strong> is a supplementary guide designed for JavaScript developers transitioning to PureScript, focusing on selected type class concepts from Chapters 6–8 of <em>PureScript by Example</em>. These chapters introduce type classes, a powerful feature that can feel abstract to those used to JavaScript’s dynamic, informal patterns. This booklet serves as a companion to those chapters, offering a JavaScript-centric perspective to make PureScript’s type classes intuitive by connecting them to familiar JavaScript practices.</p>
<h3 id="purpose-and-approach"><a class="header" href="#purpose-and-approach">Purpose and Approach</a></h3>
<p>As a JavaScript developer, you likely use patterns like string conversion, equality checks, combining data, mapping arrays, or validating collections, often with ad hoc solutions like <code>toString</code>, <code>===</code>, or <code>Array.prototype.map</code>. These approaches are flexible but prone to runtime errors and lack structure. PureScript’s type classes formalize these patterns with type safety, ensuring reliability without introducing complexity beyond what you encounter in modern web development. This booklet achieves this by:</p>
<ol>
<li><strong>Starting with JavaScript Patterns</strong>: Each section begins with a familiar JavaScript pattern, such as converting objects to strings, comparing values, concatenating arrays, or validating form inputs, to ground the discussion in what you already know.</li>
<li><strong>Formalizing with PureScript’s Type Classes</strong>: We show how PureScript’s type classes (e.g., <code>Show</code>, <code>Eq</code>, <code>Ord</code>, <code>Semigroup</code>, <code>Monoid</code>, <code>Functor</code>, <code>Foldable</code>, <code>Applicative</code>, <code>Traversable</code>,  <code>Monad</code>) provide structured, type-safe versions of these patterns, solving JavaScript’s pain points like unpredictable behavior or error-prone code.</li>
<li><strong>Highlighting Familiarity and Simplicity</strong>: We emphasize that these type classes mirror informal JavaScript practices, formalizing them without exceeding the complexity of modern web development, making PureScript accessible and practical.</li>
</ol>
<h3 id="who-this-is-for"><a class="header" href="#who-this-is-for">Who This Is For</a></h3>
<p>This booklet is for JavaScript developers who are:</p>
<ul>
<li>Learning PureScript and finding the type class concepts in Chapters 6–8 of <em>PureScript by Example</em> abstract or hard to relate to.</li>
<li>Comfortable with JavaScript (ES5 or later, including modern frameworks like React or Node.js) but new to strongly-typed functional programming.</li>
<li>Curious about how PureScript’s type system can enhance familiar JavaScript patterns with safety and clarity.</li>
</ul>
<h3 id="how-to-read-this-booklet"><a class="header" href="#how-to-read-this-booklet">How to Read This Booklet</a></h3>
<ul>
<li><strong>As a Supplement</strong>: Use this booklet alongside <em>PureScript by Example</em>. Each section covers selected type classes from Chapters 6 (Type Classes), 7 (Applicative Functors, Traversable Functors), 8 (Monads, though limited to concepts with clear JavaScript analogs), and 9 (more advanced type classes, selectively covered). Read these sections first to build intuition, then complete the corresponding exercises in <em>PureScript by Example</em> for hands-on practice. <strong>Note</strong>: Some concepts within <em>PureScript By Example</em> do not have a strong JavaScript analog; they are excluded but should still be read by the reader of the booklet.</li>
<li><strong>With Code Examples</strong>: Each section includes JavaScript and PureScript code snippets to illustrate parallels and differences. Experiment with the PureScript examples in the REPL (e.g., using <code>spago repl</code>) to reinforce your understanding.</li>
</ul>
<h3 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You’ll Learn</a></h3>
<p>By the end of this booklet, you’ll:</p>
<ul>
<li>Understand how PureScript’s type classes like <code>Show</code>, <code>Eq</code>, <code>Ord</code>, <code>Semigroup</code>, <code>Monoid</code>, <code>Functor</code>, <code>Foldable</code>, <code>Applicative</code>, <code>Traversable</code>, and <code>Monad</code> relate to JavaScript patterns such as string conversion, equality checks, data combination, array mapping, and collection validation.</li>
<li>See how these type classes formalize JavaScript’s informal practices, providing type-safe, reusable solutions that align with modern web development’s complexity.</li>
<li>Gain confidence in writing PureScript code that leverages type classes to create robust, maintainable programs, enhancing your JavaScript workflows.</li>
</ul>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>To get the most out of this booklet, you should:</p>
<ul>
<li>Have a working knowledge of JavaScript (e.g., functions, objects, arrays, and common APIs like <code>map</code> or <code>reduce</code>).</li>
<li>Understand the basics of PureScript, such as types, data declarations, and function syntax (covered in Chapters 1–5 of <em>PureScript by Example</em>).</li>
<li>Have a PureScript development environment set up (e.g., via <code>spago</code> and <code>purs</code>) to run examples.</li>
</ul>
<p>Let’s dive in and explore how PureScript’s type classes bring structure and safety to the JavaScript patterns you already use, making your code more reliable without overwhelming complexity!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-classes"><a class="header" href="#type-classes">Type Classes</a></h1>
<p>This booklet covers some Type Classes from chapters 6-8 of PureScript By Example. We recommend readers use it alongside certain sections of the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="show"><a class="header" href="#show">Show</a></h2>
<h3 id="the-javascript-struggle-debugging-complex-objects"><a class="header" href="#the-javascript-struggle-debugging-complex-objects">The JavaScript Struggle: Debugging Complex Objects</a></h3>
<p>JavaScript developers often debug by logging objects to the console. Suppose you’re working with a user profile object:</p>
<pre><code class="language-javascript">const userProfile = {
  name: "Alice",
  settings: { theme: "dark", notifications: true },
  preferences: ["email", "sms"]
};
console.log(userProfile); 
// { name: "Alice", settings: { theme: "dark", notifications: true }, preferences: ["email", "sms"] }
console.log(userProfile.toString()); 
// "[object Object]"
console.log(JSON.stringify(userProfile)); 
// "{\"name\":\"Alice\",\"settings\":{\"theme\":\"dark\",\"notifications\":true},\"preferences\":[\"email\",\"sms\"]}"
</code></pre>
<p>The default <code>console.log</code> is verbose, <code>toString</code> is useless, and <code>JSON.stringify</code> is better but clunky with quotes and braces. If <code>settings</code> lacks a custom <code>toString</code> or <code>toJSON</code>, or if you add a non-serializable property like a function, things break:</p>
<pre><code class="language-javascript">userProfile.callback = () =&gt; console.log("hi");
console.log(JSON.stringify(userProfile)); 
// Omits `callback`: "{\"name\":\"Alice\",\"settings\":{\"theme\":\"dark\",\"notifications\":true},\"preferences\":[\"email\",\"sms\"]}"
</code></pre>
<p>You need to manually define <code>toJSON</code> or <code>toString</code> for every nested object to get useful output, and there’s no guarantee it’ll work consistently. Debugging complex objects in JavaScript often feels like a chore.</p>
<h3 id="purescripts-show-clean-safe-and-automatic"><a class="header" href="#purescripts-show-clean-safe-and-automatic">PureScript’s <code>Show</code>: Clean, Safe, and Automatic</a></h3>
<p>PureScript’s <code>Show</code> type class makes debugging complex types effortless with type-safe, customizable string conversion. It’s defined as:</p>
<pre><code class="language-purescript">class Show a where
  show :: a -&gt; String
</code></pre>
<p>Every type used with <code>show</code> must have a <code>Show</code> instance, enforced by the compiler. Let’s define <code>userProfile</code> in In PSCi:</p>
<pre><code class="language-purescript">import Effect.Console

newtype UserProfile = UserProfile { name :: String, settings :: Settings, preferences :: Array String }
newtype Settings = Settings { theme :: String, notifications :: Boolean }

instance Show Settings where
  show (Settings { theme, notifications }) = "(Settings " &lt;&gt; show theme &lt;&gt; " " &lt;&gt; show notifications &lt;&gt; ")"

instance Show UserProfile where
  show (UserProfile { name, settings, preferences }) = "(UserProfile " &lt;&gt; show name &lt;&gt; " " &lt;&gt; show settings &lt;&gt; " " &lt;&gt; show preferences &lt;&gt; ")"

logShow (UserProfile { name: "Alice", settings: Settings { theme: "dark", notifications: true }, preferences: ["email", "sms"] })
</code></pre>
<p>This output is clean, readable, and a valid PureScript expression you can paste back into PSCi to recreate the value. Unlike JavaScript, <code>Show</code> ensures consistency and catches errors early.</p>
<h3 id="why-show-excites-javascript-developers"><a class="header" href="#why-show-excites-javascript-developers">Why <code>Show</code> Excites JavaScript Developers</a></h3>
<ol>
<li>
<p><strong>No More <code>[object Object]</code></strong>: Unlike <code>toString</code>, <code>Show</code> guarantees meaningful output for every type, enforced at compile time. Forget a <code>Show</code> instance, and the compiler stops you:</p>
<pre><code class="language-purescript">&gt; show (\n -&gt; n + 1)
-- Error: No type class instance was found for Data.Show.Show (Int -&gt; Int)
</code></pre>
</li>
<li>
<p><strong>Automatic Nesting</strong>: <code>Show</code> composes effortlessly. The <code>UserProfile</code> instance reuses <code>Show</code> for <code>Settings</code>, <code>String</code>, and <code>Array String</code>, saving you from defining string conversions for every nested type, unlike <code>toJSON</code> or <code>toString</code>.</p>
</li>
<li>
<p><strong>Debugging Bliss</strong>: The output is concise and REPL-friendly, perfect for quick debugging. Compare <code>(UserProfile "Alice" (Settings "dark" true) ["email","sms"])</code> to JSON’s verbose <code>{"name":"Alice","settings":{"theme":"dark","notifications":true},"preferences":["email","sms"]}</code>.</p>
</li>
</ol>
<h3 id="but-what-about-jsonstringify"><a class="header" href="#but-what-about-jsonstringify">But What About <code>JSON.stringify</code>?</a></h3>
<p><code>JSON.stringify</code> is great for serializing data for APIs or storage—its JSON output is standard and interoperable. However, for debugging, it’s verbose, drops non-serializable data (e.g., functions), and requires manual <code>toJSON</code> definitions for custom formats. <code>Show</code> is tailored for PureScript’s REPL-driven, type-safe workflow, offering concise, reconstructible output and automatic composition for complex types like <code>userProfile</code>. If you’re serializing for an API, use a PureScript JSON library like <code>purescript-argonaut</code>; for debugging, <code>Show</code> is your friend.</p>
<h3 id="repl-exercises"><a class="header" href="#repl-exercises">REPL Exercises</a></h3>
<p>Try these in PSCi to see <code>Show</code> in action. Copy and paste each block:</p>
<ol>
<li>
<p><strong>Show Basic Types</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
logShow true
logShow 1.0
logShow "Hello"
</code></pre>
<p>Expected output:</p>
<pre><code>true
unit
1.0
unit
"Hello"
unit
</code></pre>
</li>
<li>
<p><strong>Show a Nested Type</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
newtype Settings = Settings { theme :: String, notifications :: Boolean }
instance Show Settings where
  show (Settings { theme, notifications }) = "(Settings " &lt;&gt; show theme &lt;&gt; " " &lt;&gt; show notifications &lt;&gt; ")"
logShow (Settings { theme: "dark", notifications: true })
</code></pre>
<p>Expected output:</p>
<pre><code>(Settings "dark" true)
unit
</code></pre>
</li>
<li>
<p><strong>Show a Complex Type</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
newtype Settings = Settings { theme :: String, notifications :: Boolean }
instance Show Settings where
  show (Settings { theme, notifications }) = "(Settings " &lt;&gt; show theme &lt;&gt; " " &lt;&gt; show notifications &lt;&gt; ")"
newtype UserProfile = UserProfile { name :: String, settings :: Settings }
instance Show UserProfile where
  show (UserProfile { name, settings }) = "(UserProfile " &lt;&gt; show name &lt;&gt; " " &lt;&gt; show settings &lt;&gt; ")"
logShow (UserProfile { name: "Alice", settings: Settings { theme: "dark", notifications: true } })
</code></pre>
<p>Expected output:</p>
<pre><code>(UserProfile "Alice" (Settings "dark" true))
unit
</code></pre>
</li>
<li>
<p><strong>Test Type Safety</strong>:</p>
<pre><code class="language-purescript">import Prelude
show (\n -&gt; n + 1)
</code></pre>
<p>Expected output: A compile-time error, showing <code>Show</code>’s safety:</p>
<pre><code>Error: No type class instance was found for Data.Show.Show (Int -&gt; Int)
</code></pre>
</li>
</ol>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>JavaScript’s <code>toString</code> and <code>JSON.stringify</code> struggle with debugging complex objects like <code>userProfile</code>, requiring manual hacks and risking inconsistent output. PureScript’s <code>Show</code> type class offers a type-safe, composable, and REPL-friendly way to convert values to strings, making debugging a breeze. For JavaScript developers diving into PureScript, <code>Show</code> transforms the frustration of <code>[object Object]</code> into clean, reliable output, perfect for interactive development.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="eq"><a class="header" href="#eq">Eq</a></h2>
<h3 id="the-javascript-struggle-comparing-objects"><a class="header" href="#the-javascript-struggle-comparing-objects">The JavaScript Struggle: Comparing Objects</a></h3>
<p>In JavaScript, comparing objects for equality is a common task, but it’s fraught with pitfalls. The <code>===</code> operator checks for strict equality, which works well for primitives like numbers and strings but often fails for complex objects:</p>
<pre><code class="language-javascript">const user1 = { id: 1, name: "Alice" };
const user2 = { id: 1, name: "Alice" };
console.log(user1 === user2); // false
console.log(user1 == user2); // false
</code></pre>
<p>Why? JavaScript’s <code>===</code> compares object references, not values. Even though <code>user1</code> and <code>user2</code> look identical, they’re different objects in memory. To compare their contents, you’d need a custom function:</p>
<pre><code class="language-javascript">function areUsersEqual(user1, user2) {
  return user1.id === user2.id &amp;&amp; user1.name === user2.name;
}
console.log(areUsersEqual(user1, user2)); // true
</code></pre>
<p>This works but is tedious. You must write a new comparison function for every object type, and there’s no built-in way to enforce that objects support equality checks. For nested objects, it gets messier:</p>
<pre><code class="language-javascript">const profile1 = { user: { id: 1, name: "Alice" }, settings: { theme: "dark" } };
const profile2 = { user: { id: 1, name: "Alice" }, settings: { theme: "dark" } };
console.log(areUsersEqual(profile1, profile2)); // Error: settings not checked
</code></pre>
<p>You’d need to extend <code>areUsersEqual</code> to recursively compare <code>settings</code>, and if the object structure changes, you must update the function manually. Libraries like Lodash’s <code>_.isEqual</code> can help, but they’re still runtime solutions with no guarantee of correctness for all types.</p>
<h3 id="purescripts-eq-type-safe-equality"><a class="header" href="#purescripts-eq-type-safe-equality">PureScript’s <code>Eq</code>: Type-Safe Equality</a></h3>
<p>PureScript’s <code>Eq</code> type class provides a standardized, type-safe way to compare values for equality. It’s defined as:</p>
<pre><code class="language-purescript">class Eq a where
  eq :: a -&gt; a -&gt; Boolean
</code></pre>
<p>The <code>==</code> operator is an alias for <code>eq</code>, and any type used with <code>==</code> must have an <code>Eq</code> instance, enforced by the compiler. Let’s define the <code>profile</code> example in PureScript:</p>
<pre><code class="language-purescript">import Prelude

newtype User = User { id :: Int, name :: String }
newtype Profile = Profile { user :: User, settings :: Settings }
newtype Settings = Settings { theme :: String }

instance Eq User where
  eq (User u1) (User u2) = u1.id == u2.id &amp;&amp; u1.name == u2.name

instance Eq Settings where
  eq (Settings s1) (Settings s2) = s1.theme == s2.theme

instance Eq Profile where
  eq (Profile p1) (Profile p2) = p1.user == p2.user &amp;&amp; p1.settings == p2.settings

profile1 = Profile { user: User { id: 1, name: "Alice" }, settings: Settings { theme: "dark" } }
profile2 = Profile { user: User { id: 1, name: "Alice" }, settings: Settings { theme: "dark" } }
profile1 == profile2
</code></pre>
<p>Expected Output:</p>
<pre><code>true
</code></pre>
<p>This comparison is clean, and the compiler ensures every type used with <code>==</code> has an <code>Eq</code> instance. Trying to compare unsupported types fails at compile time:</p>
<pre><code class="language-purescript">&gt; (\n -&gt; n + 1) == (\n -&gt; n + 1)
-- Error: No type class instance was found for Data.Eq.Eq (Int -&gt; Int)
</code></pre>
<h3 id="why-eq-excites-javascript-developers"><a class="header" href="#why-eq-excites-javascript-developers">Why <code>Eq</code> Excites JavaScript Developers</a></h3>
<ol>
<li>
<p><strong>No More Reference Equality Traps</strong>: Unlike JavaScript’s <code>===</code>, which fails for identical objects, <code>Eq</code> lets you define value-based equality for custom types like <code>Profile</code>, making comparisons intuitive.</p>
</li>
<li>
<p><strong>Automatic Composition</strong>: The <code>Profile</code> instance reuses <code>Eq</code> instances for <code>User</code> and <code>Settings</code>. You don’t need to write recursive comparison logic manually, unlike JavaScript’s custom functions or <code>_.isEqual</code>.</p>
</li>
<li>
<p><strong>Type-Safe Guarantees</strong>: The compiler enforces that every type used with <code>==</code> has an <code>Eq</code> instance, catching errors early. In JavaScript, you might not notice a missing or incorrect comparison until runtime.</p>
</li>
</ol>
<h3 id="but-what-about-lodashs-_isequal"><a class="header" href="#but-what-about-lodashs-_isequal">But What About Lodash’s <code>_.isEqual</code>?</a></h3>
<p>JavaScript developers might use <code>_.isEqual</code> for deep equality checks:</p>
<pre><code class="language-javascript">const _ = require('lodash');
console.log(_.isEqual(profile1, profile2)); // true
</code></pre>
<p><code>_.isEqual</code> is convenient and handles nested objects, but it’s a runtime solution with no type checking. It works for any object but might hide bugs if objects have non-comparable properties (e.g., functions). <code>Eq</code> requires explicit instances, ensuring correctness at compile time, and is tailored for PureScript’s type-driven development, where you want precise control over equality.</p>
<h3 id="repl-exercises-1"><a class="header" href="#repl-exercises-1">REPL Exercises</a></h3>
<p>Try these in PSCi to explore <code>Eq</code>. Copy and paste each block:</p>
<ol>
<li>
<p><strong>Compare Basic Types</strong>:</p>
<pre><code class="language-purescript">import Prelude
1 == 2
"Test" == "Test"
</code></pre>
<p>Expected output:</p>
<pre><code>false
true
</code></pre>
</li>
<li>
<p><strong>Compare a Custom Type</strong>:</p>
<pre><code class="language-purescript">import Prelude
newtype User = User { id :: Int, name :: String }
instance Eq User where
  eq (User u1) (User u2) = u1.id == u2.id &amp;&amp; u1.name == u2.name
User { id: 1, name: "Alice" } == User { id: 1, name: "Alice" }
User { id: 1, name: "Alice" } == User { id: 2, name: "Bob" }
</code></pre>
<p>Expected output:</p>
<pre><code>true
false
</code></pre>
</li>
<li>
<p><strong>Compare a Nested Type</strong>:</p>
<pre><code class="language-purescript">import Prelude
newtype User = User { id :: Int, name :: String }
newtype Profile = Profile { user :: User }
instance Eq User where
  eq (User u1) (User u2) = u1.id == u2.id &amp;&amp; u1.name == u2.name
instance Eq Profile where
  eq (Profile p1) (Profile p2) = p1.user == p2.user
Profile { user: User { id: 1, name: "Alice" } } == Profile { user: User { id: 1, name: "Alice" } }
</code></pre>
<p>Expected output:</p>
<pre><code>true
</code></pre>
</li>
<li>
<p><strong>Test Type Safety</strong>:</p>
<pre><code class="language-purescript">import Prelude
(\n -&gt; n + 1) == (\n -&gt; n + 1)
</code></pre>
<p>Expected output: A compile-time error:</p>
<pre><code>Error: No type class instance was found for Data.Eq.Eq (Int -&gt; Int)
</code></pre>
</li>
</ol>
<h3 id="summary-1"><a class="header" href="#summary-1">Summary</a></h3>
<p>JavaScript’s <code>===</code> and <code>_.isEqual</code> struggle with object comparisons, requiring manual functions or runtime checks. PureScript’s <code>Eq</code> type class offers a type-safe, composable way to define equality for custom types like <code>Profile</code>, catching errors at compile time and simplifying nested comparisons. For JavaScript developers, <code>Eq</code> eliminates the guesswork of equality checks, making PureScript’s type-driven approach a game-changer for reliable code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ord"><a class="header" href="#ord">Ord</a></h2>
<h3 id="the-javascript-struggle-sorting-objects"><a class="header" href="#the-javascript-struggle-sorting-objects">The JavaScript Struggle: Sorting Objects</a></h3>
<p>JavaScript developers often need to sort or compare objects, like user profiles, by specific fields. The comparison operators (<code>&lt;</code>, <code>&gt;</code>) work for numbers and strings but fail for objects:</p>
<pre><code class="language-javascript">const user1 = { id: 1, name: "Alice" };
const user2 = { id: 2, name: "Bob" };
console.log(user1 &lt; user2); // false (coerces to strings: "[object Object]")
</code></pre>
<p>JavaScript’s <code>&lt;</code> operator isn’t helpful here, as it compares object references or stringified versions. To sort an array of users by <code>id</code>, you write a custom function for <code>Array.sort</code>:</p>
<pre><code class="language-javascript">const users = [
  { id: 2, name: "Bob" },
  { id: 1, name: "Alice" }
];
users.sort((a, b) =&gt; a.id - b.id);
console.log(users); // [{ id: 1, name: "Alice" }, { id: 2, name: "Bob" }]
</code></pre>
<p>This works but requires a new comparison function for every object type or sorting criterion. For nested objects, like a <code>profile</code> with a <code>user</code>, it’s even more tedious:</p>
<pre><code class="language-javascript">const profile1 = { user: { id: 2, name: "Bob" }, settings: { theme: "dark" } };
const profile2 = { user: { id: 1, name: "Alice" }, settings: { theme: "light" } };
profiles.sort((a, b) =&gt; a.user.id - b.user.id);
</code></pre>
<p>You must manually navigate nested fields, and there’s no guarantee the comparison is defined or consistent. Libraries like Lodash’s <code>_.orderBy</code> help, but they’re still runtime solutions without type safety.</p>
<h3 id="purescripts-ord-type-safe-ordering"><a class="header" href="#purescripts-ord-type-safe-ordering">PureScript’s <code>Ord</code>: Type-Safe Ordering</a></h3>
<p>PureScript’s <code>Ord</code> type class provides a standardized, type-safe way to compare values for ordering, building on the <code>Eq</code> type class for equality. It’s defined as:</p>
<pre><code class="language-purescript">data Ordering = LT | EQ | GT

class Eq a &lt;= Ord a where
  compare :: a -&gt; a -&gt; Ordering
</code></pre>
<p>The <code>compare</code> function returns <code>LT</code> (less than), <code>EQ</code> (equal), or <code>GT</code> (greater than), and operators like <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> are built on <code>compare</code>. The <code>Eq</code> superclass ensures that <code>compare a b == EQ</code> aligns with <code>a == b</code>. Here’s the <code>profile</code> example in PureScript:</p>
<pre><code class="language-purescript">import Prelude
import Data.Array
import Effect.Console

newtype AppUser = AppUser { id :: Int, name :: String }
newtype Settings = Settings { theme :: String }
newtype Profile = Profile { user :: AppUser, settings :: Settings }

derive instance Eq AppUser
derive instance Eq Settings
derive instance Eq Profile

instance Ord AppUser where
  compare (AppUser u1) (AppUser u2) = compare u1.id u2.id

instance Ord Settings where
  compare (Settings s1) (Settings s2) = compare s1.theme s2.theme

instance Ord Profile where
  compare (Profile p1) (Profile p2) = compare p1.user p2.user

instance Show Settings where
  show (Settings { theme }) = "(Settings " &lt;&gt; show theme &lt;&gt; " )"

instance Show AppUser where
  show (AppUser { id, name }) = "(AppUser " &lt;&gt; show id &lt;&gt; " " &lt;&gt; show name &lt;&gt; ")"

instance Show Profile where
  show (Profile { user, settings}) = "(Profile " &lt;&gt; show user &lt;&gt; " " &lt;&gt; show settings &lt;&gt; ")"

profile1 = Profile { user: AppUser { id: 2, name: "Bob" }, settings: Settings { theme: "dark" } }
profile2 = Profile { user: AppUser { id: 1, name: "Alice" }, settings: Settings { theme: "light" } }

compare profile1 profile2

profile1 &lt; profile2

logShow $ sort [profile1, profile2]


</code></pre>
<p>Expected Output:</p>
<pre><code>GT

false

[(Profile (AppUser 1 "Alice") (Settings "light")), (Profile (AppUser 2 "Bob") (Settings "dark"))]

</code></pre>
<p>The <code>sort</code> function uses <code>Ord</code> to order by <code>user.id</code>. The compiler ensures every type used with <code>compare</code> or <code>&lt;</code> has an <code>Ord</code> instance, preventing errors:</p>
<pre><code class="language-purescript">&gt; compare (\n -&gt; n + 1) (\n -&gt; n + 1)
-- Error: No type class instance was found for Data.Ord.Ord (Int -&gt; Int)
</code></pre>
<h3 id="why-ord-excites-javascript-developers"><a class="header" href="#why-ord-excites-javascript-developers">Why <code>Ord</code> Excites JavaScript Developers</a></h3>
<ol>
<li>
<p><strong>No Custom Sort Functions</strong>: Unlike JavaScript’s <code>sort</code> with one-off comparison functions, <code>Ord</code> defines a reusable <code>compare</code> function per type, making ordering consistent.</p>
</li>
<li>
<p><strong>Composes Effortlessly</strong>: The <code>Profile</code> instance reuses <code>AppUser</code>’s <code>Ord</code> instance, which reuses <code>Int</code>’s. No need to manually dig into nested fields like in JavaScript.</p>
</li>
<li>
<p><strong>Type-Safe Sorting</strong>: Compile-time checks ensure <code>Ord</code> instances exist, eliminating runtime errors from undefined comparisons.</p>
</li>
</ol>
<h3 id="but-what-about-lodashs-_orderby"><a class="header" href="#but-what-about-lodashs-_orderby">But What About Lodash’s <code>_.orderBy</code>?</a></h3>
<p>Lodash’s <code>_.orderBy</code> simplifies sorting:</p>
<pre><code class="language-javascript">const _ = require('lodash');
console.log(_.orderBy([profile1, profile2], ['user.id'], ['asc']));
// [{ user: { id: 1, name: "Alice" }, settings: { theme: "light" } }, ...]
</code></pre>
<p>It’s flexible but runtime-based. Misspelling <code>user.id</code> or using an invalid property causes errors at runtime. <code>Ord</code> ensures correctness at compile time and integrates with PureScript’s <code>sort</code>, streamlining type-safe development.</p>
<h3 id="repl-exercises-2"><a class="header" href="#repl-exercises-2">REPL Exercises</a></h3>
<p>Try these in a fresh PSCi session (run <code>:reset</code> first) to explore <code>Ord</code>. Copy and paste each block:</p>
<ol>
<li>
<p><strong>Compare Basic Types</strong>:</p>
<pre><code class="language-purescript">import Prelude
compare 1 2
compare "A" "Z"
</code></pre>
<p>Expected output:</p>
<pre><code>LT
LT
</code></pre>
</li>
<li>
<p><strong>Compare a Custom Type</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Data.Array
import Effect.Console

newtype AppUser = AppUser { id :: Int, name :: String }
newtype Settings = Settings { theme :: String }
newtype Profile = Profile { user :: AppUser, settings :: Settings }

derive instance Eq AppUser
derive instance Eq Settings
derive instance Eq Profile

instance Ord AppUser where
  compare (AppUser u1) (AppUser u2) = compare u1.id u2.id

instance Ord Settings where
  compare (Settings s1) (Settings s2) = compare s1.theme s2.theme

instance Ord Profile where
  compare (Profile p1) (Profile p2) = compare p1.user p2.user

instance Show Settings where
  show (Settings { theme }) = "(Settings " &lt;&gt; show theme &lt;&gt; " )"

instance Show AppUser where
  show (AppUser { id, name }) = "(AppUser " &lt;&gt; show id &lt;&gt; " " &lt;&gt; show name &lt;&gt; ")"

instance Show Profile where
  show (Profile { user, settings}) = "(Profile " &lt;&gt; show user &lt;&gt; " " &lt;&gt; show settings &lt;&gt; ")"

profile1 = Profile { user: AppUser { id: 2, name: "Bob" }, settings: Settings { theme: "dark" } }
profile2 = Profile { user: AppUser { id: 1, name: "Alice" }, settings: Settings { theme: "light" } }

compare profile1 profile2

profile1 &lt; profile2


</code></pre>
<p>Expected Output:</p>
<pre><code>GT

false

</code></pre>
</li>
<li>
<p><strong>Sort an Array</strong>:</p>
<pre><code class="language-purescript">logShow $ sort [profile1, profile2]
</code></pre>
<p>Expected output:</p>
<pre><code>[(Profile (AppUser 1 "Alice") (Settings "light")), (Profile (AppUser 2 "Bob") (Settings "dark"))]
unit
</code></pre>
</li>
<li>
<p><strong>Test Type Safety</strong>:</p>
<pre><code class="language-purescript">import Prelude
compare (\n -&gt; n + 1) (\n -&gt; n + 1)
</code></pre>
<p>Expected output:</p>
<pre><code>Error: No type class instance was found for Data.Ord.Ord (Int -&gt; Int)
</code></pre>
</li>
</ol>
<h3 id="summary-2"><a class="header" href="#summary-2">Summary</a></h3>
<p>JavaScript’s sorting requires custom, error-prone comparison functions for objects like <code>profile</code>. PureScript’s <code>Ord</code> type class offers a type-safe, reusable way to define ordering, with automatic composition for nested types and compile-time guarantees. For JavaScript developers, <code>Ord</code> eliminates the hassle of ad hoc sorting, making PureScript’s type-driven approach a powerful tool for reliable code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="semigroups-and-monoids"><a class="header" href="#semigroups-and-monoids">Semigroups and Monoids</a></h2>
<h3 id="the-javascript-struggle-combining-values"><a class="header" href="#the-javascript-struggle-combining-values">The JavaScript Struggle: Combining Values</a></h3>
<p>In JavaScript, combining values like strings or arrays is common, using <code>+</code> for strings or <code>concat</code> for arrays:</p>
<pre><code class="language-javascript">console.log("Hello" + " " + "World"); // "Hello World"
console.log([1, 2, 3].concat([4, 5]); // [1, 2, 3, 4, 5]
</code></pre>
<p>But for custom types, like merging user settings objects, there's no standard way:</p>
<pre><code class="language-javascript">const settings1 = { theme: "dark", notifications: true };
const settings2 = { theme: "light", alerts: true };
const merged = { ...settings1, ...settings2 }; // { theme: "light", notifications: true, alerts: true }
console.log(merged);
</code></pre>
<p>This works but is ad hoc. You must define custom merge functions for each type, and there's no guarantee of associativity (e.g., <code>(a + b) + c == a + (b + c)</code>). Associativity means the order of grouping combinations doesn't matter, which is crucial for predictable behavior in larger operations like folding arrays. For example, consider merging user profiles with nested <code>address</code> objects:</p>
<pre><code class="language-javascript">const profileA = { name: "Alice", address: { street: "123 Main St", city: undefined, zip: undefined } };
const profileB = { name: "Bob", address: { street: undefined, city: "New York", zip: undefined } };
const profileC = { name: "Charlie", address: { street: undefined, city: undefined, zip: "10001" } };

// Merging A and B first, then with C
const result1 = { ...{ ...profileA, ...profileB }, ...profileC };
// Result: { name: "Charlie", address: { street: undefined, city: undefined, zip: "10001" } } – street and city are lost

// Merging B and C first, then with A
const result2 = { ...{ ...profileB, ...profileC }, ...profileA };
// Result: { name: "Alice", address: { street: "123 Main St", city: undefined, zip: undefined } } – city and zip are lost
</code></pre>
<p>The grouping affects which nested <code>address</code> properties survive, breaking associativity—the results aren't the same. This can lead to subtle bugs in larger merges or folds, where the order of operations unexpectedly changes the result. For empty values (like empty object <code>{}</code>), it's often clear what the "identity" is for simple spreads (it combines with any object to return the object unchanged), but for custom merges like this, <code>{}</code> might not be an identity if merging adds logic.</p>
<p>For more complex combinations, like folding an array of objects, you need custom reduce functions:</p>
<pre><code class="language-javascript">const allProfiles = [profileA, profileB, profileC];
const mergedAll = allProfiles.reduce((acc, p) =&gt; ({ ...acc, ...p }), {});
console.log(mergedAll); // { name: "Charlie", address: { street: undefined, city: undefined, zip: "10001" } } – depends on order, nested fields overwritten
</code></pre>
<p>This is flexible but error-prone, with no type safety for the combination operation or empty value.</p>
<h3 id="purescripts-semigroup-and-monoid-type-safe-combining"><a class="header" href="#purescripts-semigroup-and-monoid-type-safe-combining">PureScript’s <code>Semigroup</code> and <code>Monoid</code>: Type-Safe Combining</a></h3>
<p>PureScript’s <code>Semigroup</code> type class defines an <code>append</code> operation (alias <code>&lt;&gt;</code>) for combining values, with the law that it's associative. <code>Monoid</code> extends it with <code>mempty</code>, an identity value. They are defined as:</p>
<pre><code class="language-purescript">class Semigroup a where
  append :: a -&gt; a -&gt; a

class Semigroup m &lt;= Monoid m where
  mempty :: m
</code></pre>
<p>Strings and arrays have instances, but you can define for custom types like <code>Profile</code> with nested <code>Address</code>. To demonstrate associativity, let's define a <code>Profile</code> type with deep merging for the nested <code>address</code> fields:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Maybe
import Control.Alt ((&lt;|&gt;))

newtype Address = Address { street :: Maybe String, city :: Maybe String, zip :: Maybe String }

instance Semigroup Address where
  append (Address a1) (Address a2) = Address {
    street: a1.street &lt;|&gt; a2.street,
    city: a1.city &lt;|&gt; a2.city,
    zip: a1.zip &lt;|&gt; a2.zip
  }

instance Monoid Address where
  mempty = Address { street: Nothing, city: Nothing, zip: Nothing }

instance Show Address where
  show (Address a) = "(Address " &lt;&gt; show a &lt;&gt; ")"

newtype Profile = Profile { name :: Maybe String, address :: Address }

instance Semigroup Profile where
  append (Profile p1) (Profile p2) = Profile {
    name: p1.name &lt;|&gt; p2.name,
    address: p1.address &lt;&gt; p2.address
  }

instance Monoid Profile where
  mempty = Profile { name: Nothing, address: mempty }

instance Show Profile where
  show (Profile p) = "(Profile " &lt;&gt; show p &lt;&gt; ")"

a = Profile { name: Just "Alice", address: Address { street: Just "123 Main St", city: Nothing, zip: Nothing } }
b = Profile { name: Just "Bob", address: Address { street: Nothing, city: Just "New York", zip: Nothing } }
c = Profile { name: Just "Charlie", address: Address { street: Nothing, city: Nothing, zip: Just "10001" } }

logShow $ (a &lt;&gt; b) &lt;&gt; c
logShow $ a &lt;&gt; (b &lt;&gt; c)

</code></pre>
<p>Expected output:</p>
<pre><code>(Profile { name: (Just "Alice"), address: (Address { street: (Just "123 Main St"), city: (Just "New York"), zip: (Just "10001") }) })
unit
&gt; logShow $ a &lt;&gt; (b &lt;&gt; c)
(Profile { name: (Just "Alice"), address: (Address { street: (Just "123 Main St"), city: (Just "New York"), zip: (Just "10001") }) })
unit
</code></pre>
<p>The results are the same regardless of grouping, adhering to the associativity law. This encourages designs where combinations are predictable and deep merging is explicit, avoiding the pitfalls in JavaScript's custom merges. The compiler ensures all types used with <code>&lt;&gt;</code> have a <code>Semigroup</code> instance, and the laws (associativity, identity) are enforced by convention.</p>
<h3 id="why-semigroup-and-monoid-excite-javascript-developers"><a class="header" href="#why-semigroup-and-monoid-excite-javascript-developers">Why <code>Semigroup</code> and <code>Monoid</code> Excite JavaScript Developers</a></h3>
<ol>
<li>
<p><strong>Standardized Combining</strong>: Unlike JavaScript’s ad hoc merges, <code>Semigroup</code> provides a consistent <code>&lt;&gt;</code> , reusable for custom types like <code>Profile</code>.</p>
</li>
<li>
<p><strong>Identity Value</strong>: <code>Monoid</code>’s <code>mempty</code> gives a clear empty value, like <code>{}</code> in JavaScript for simple merges, but type-safe and guaranteed.</p>
</li>
<li>
<p><strong>Type-Safe Folds</strong>: Combine with <code>Foldable</code> (which we'll cover later) for safe, efficient folding, with compile-time checks— no runtime surprises from undefined merges.</p>
</li>
</ol>
<h3 id="but-what-about-javascripts--or-objectassign"><a class="header" href="#but-what-about-javascripts--or-objectassign">But What About JavaScript’s <code>+</code> or <code>Object.assign</code>?</a></h3>
<p>JavaScript’s <code>+</code> works for strings/arrays, and <code>Object.assign</code> for objects:</p>
<pre><code class="language-javascript">const merged = Object.assign({}, settings1, settings2);
</code></pre>
<p>It's flexible but runtime-only, with no associativity guarantees or type safety. <code>Semigroup</code> and <code>Monoid</code> provide compile-time safety and laws for reliable combinations.</p>
<h3 id="repl-exercises-3"><a class="header" href="#repl-exercises-3">REPL Exercises</a></h3>
<p>Try these in a fresh PSCi session (run <code>:clear</code> first). Copy and paste each block:</p>
<ol>
<li>
<p><strong>Combine Strings and Arrays</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
logShow $ "Hello" &lt;&gt; " " &lt;&gt; "World"
logShow $ [1, 2, 3] &lt;&gt; [4, 5]
</code></pre>
<p>Expected output:</p>
<pre><code>"Hello World"
unit
[1,2,3,4,5]
unit
</code></pre>
</li>
<li>
<p><strong>Use Monoid Empty</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Monoid
logShow $ mempty &lt;&gt; "Hello" &lt;&gt; mempty
logShow $ mempty &lt;&gt; [1, 2] &lt;&gt; mempty
</code></pre>
<p>Expected output:</p>
<pre><code>"Hello"
unit
[1,2]
unit
</code></pre>
</li>
<li>
<p><strong>Custom Type Combining</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Monoid
import Data.Maybe
import Control.Alt ((&lt;|&gt;))
newtype Address = Address { street :: Maybe String, city :: Maybe String, zip :: Maybe String }
instance Semigroup Address where
  append (Address a1) (Address a2) = Address {
    street: a1.street &lt;|&gt; a2.street,
    city: a1.city &lt;|&gt; a2.city,
    zip: a1.zip &lt;|&gt; a2.zip
  }
instance Monoid Address where
  mempty = Address { street: Nothing, city: Nothing, zip: Nothing }
instance Show Address where
  show (Address a) = "(Address " &lt;&gt; show a &lt;&gt; ")"
newtype Profile = Profile { name :: Maybe String, address :: Address }
instance Semigroup Profile where
  append (Profile p1) (Profile p2) = Profile {
    name: p1.name &lt;|&gt; p2.name,
    address: p1.address &lt;&gt; p2.address
  }
instance Monoid Profile where
  mempty = Profile { name: Nothing, address: mempty }
instance Show Profile where
  show (Profile p) = "(Profile " &lt;&gt; show p &lt;&gt; ")"
logShow $ Profile { name: Just "Alice", address: Address { street: Just "123 Main St", city: Nothing, zip: Nothing } } &lt;&gt; Profile { name: Nothing, address: Address { street: Nothing, city: Just "New York", zip: Just "10001" } }
</code></pre>
<p>Expected output:</p>
<pre><code>(Profile { name: (Just "Alice"), address: (Address { street: (Just "123 Main St"), city: (Just "New York"), zip: (Just "10001") }) })
unit
</code></pre>
</li>
</ol>
<h3 id="summary-3"><a class="header" href="#summary-3">Summary</a></h3>
<p>JavaScript’s combining operations like <code>+</code> and <code>Object.assign</code> are ad hoc and lack safety for custom types like <code>Profile</code>. PureScript’s <code>Semigroup</code> and <code>Monoid</code> type classes offer a type-safe, associative way to combine values, with an identity for folding, making code more reliable and reusable. For JavaScript developers, these classes bring structure to combinations, reducing bugs in data aggregation.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="foldable"><a class="header" href="#foldable">Foldable</a></h2>
<h3 id="the-javascript-struggle-reducing-collections"><a class="header" href="#the-javascript-struggle-reducing-collections">The JavaScript Struggle: Reducing Collections</a></h3>
<p>In JavaScript, reducing a collection to a single value is common, using <code>Array.reduce</code>:</p>
<pre><code class="language-javascript">const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, x) =&gt; acc + x, 0); // 15
console.log(sum);
const concatenated = numbers.reduce((acc, x) =&gt; acc + x.toString(), ""); // "12345"
console.log(concatenated);
</code></pre>
<p>This works for arrays, but for other structures like optional values (similar to Maybe) or pairs (similar to Tuple), there's no standard way. For an optional value, you might hack it:</p>
<pre><code class="language-javascript">const optionalNumber = 42; // or null
const sumOptional = optionalNumber ? 0 + optionalNumber : 0; // 42
console.log(sumOptional);
</code></pre>
<p>For a pair:</p>
<pre><code class="language-javascript">const pair = { first: 1, second: 2 };
const sumPair = pair.first + pair.second; // 3 - manual, not generalized
console.log(sumPair);
</code></pre>
<p>You must define custom reduce functions for each type, and there's no unified way to fold over different structures. For non-array collections like objects (as maps), you need <code>Object.values</code> or <code>Object.keys</code> with reduce, which is ad hoc and error-prone:</p>
<pre><code class="language-javascript">const obj = { a: 1, b: 2, c: 3 };
const sumObj = Object.values(obj).reduce((acc, x) =&gt; acc + x, 0); // 6
console.log(sumObj);
</code></pre>
<p>Even more problematic are <code>Map</code> objects, which are iterable but lack a built-in reduce. You must convert to an array first:</p>
<pre><code class="language-javascript">const myMap = new Map([['a', 1], ['b', 2], ['c', 3]]);
const sumMap = Array.from(myMap.values()).reduce((acc, v) =&gt; acc + v, 0); // 6
console.log(sumMap);
const concatenatedKeys = Array.from(myMap.keys()).reduce((acc, k) =&gt; acc + k, ""); // "abc"
console.log(concatenatedKeys);
</code></pre>
<p>This conversion is repetitive and inefficient for large Maps. Forget it, and you get runtime errors. No type safety checks if the values are reducible (e.g., numbers for sum).</p>
<h3 id="purescripts-foldable-type-safe-folding"><a class="header" href="#purescripts-foldable-type-safe-folding">PureScript’s <code>Foldable</code>: Type-Safe Folding</a></h3>
<p>PureScript’s <code>Foldable</code> type class provides a standardized way to fold over container types like arrays, <code>Maybe</code>, <code>Tuple</code>, and maps, reducing them to a single value. It’s defined as:</p>
<pre><code class="language-purescript">class Foldable f where
  foldr :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldl :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; f a -&gt; b
  foldMap :: forall a m. Monoid m =&gt; (a -&gt; m) -&gt; f a -&gt; m
</code></pre>
<p><code>foldr</code> and <code>foldl</code> are right and left folds, like JS reduceRight and reduce. <code>foldMap</code> is powerful: it maps each element to a monoid value and combines them using the monoid's <code>&lt;&gt;</code>.</p>
<p>For arrays, <code>foldMap</code> specializes to reducing to a monoid:</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Foldable
logShow $ foldMap show [1, 2, 3, 4, 5]
</code></pre>
<p>Expected output:</p>
<pre><code>"12345"
unit
</code></pre>
<p>Here, we map each number to a string (using <code>show</code>), and combine with the string monoid (concatenation). This is like JS reduce with string concatenation, but generalized.</p>
<p><code>Foldable</code> works for other types, like <code>Maybe</code> (optional values) and <code>Tuple</code> (pairs). For example, folding a <code>Maybe</code>:</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Data.Maybe
logShow $ foldMap show (Just 42)
logShow $ foldMap show (Nothing :: Maybe Int)
</code></pre>
<p>Expected output:</p>
<pre><code>"42"
unit
""
unit
</code></pre>
<p>Folding a <code>Tuple</code> (note: folds over the second component, treating the first as fixed):</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Data.Tuple
logShow $ foldMap show (Tuple 1 2)
</code></pre>
<p>Expected output:</p>
<pre><code>"2"
unit
</code></pre>
<p>For a type like <code>Map</code> (from <code>purescript-ordered-collections</code>), which has a Foldable instance, you can fold directly without conversion:</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Data.Map as Map
import Data.Tuple
myMap = Map.fromFoldable [Tuple "a" 1, Tuple "b" 2, Tuple "c" 3]
logShow $ foldl (+) 0 myMap
logShow $ foldMap show myMap
</code></pre>
<p>Expected output:</p>
<pre><code>6
unit
"123"
unit
</code></pre>
<p>The compiler ensures all types used with fold functions have a <code>Foldable</code> instance, catching errors at compile time. <code>Foldable</code> captures the notion of an ordered container that can be reduced.</p>
<h3 id="why-foldable-is-helpful"><a class="header" href="#why-foldable-is-helpful">Why <code>Foldable</code> Is Helpful</a></h3>
<ol>
<li>
<p><strong>Generalized Reducing</strong>: Unlike JS's array-specific <code>reduce</code>, <code>Foldable</code> works on arrays, <code>Maybe</code>, <code>Tuple</code>, maps, and custom types, with a uniform interface.</p>
</li>
<li>
<p><strong>Monoid Integration</strong>: <code>foldMap</code> combines with <code>Monoid</code> (from the previous section) for safe, associative reductions, like reducing to strings or numbers, with compile-time safety.</p>
</li>
<li>
<p><strong>Type-Safe</strong>: No runtime errors from reducing non-reducible structures; the compiler enforces <code>Foldable</code> instances.</p>
</li>
</ol>
<h3 id="practical-example-reducing-user-data"><a class="header" href="#practical-example-reducing-user-data">Practical Example: Reducing User Data</a></h3>
<p>Suppose you have optional user data (Maybe) or paired data (Tuple). In JS, you'd handle each case manually. In PureScript, <code>foldMap</code> reduces uniformly:</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Foldable
import Data.Maybe
import Data.Tuple
logShow $ foldMap (\s -&gt; s &lt;&gt; " logged in") (Just "user1")
logShow $ foldMap (\s -&gt; "status: " &lt;&gt; s) (Tuple "user2" "active")
</code></pre>
<p>Expected output:</p>
<pre><code>"user1 logged in"
unit
"status: active"
unit
</code></pre>
<p>This generalizes reduce, making code reusable across structures.</p>
<h3 id="repl-exercises-4"><a class="header" href="#repl-exercises-4">REPL Exercises</a></h3>
<p>Try these in a fresh PSCi session (run <code>:clear</code> first). Copy and paste each block:</p>
<ol>
<li>
<p><strong>Fold an Array</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Foldable
logShow $ foldl (+) 0 [1, 2, 3, 4, 5]
logShow $ foldMap show [1, 2, 3, 4, 5]
</code></pre>
<p>Expected output:</p>
<pre><code>15
unit
"12345"
unit
</code></pre>
</li>
<li>
<p><strong>Fold a Maybe</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Foldable
import Data.Maybe
logShow $ foldMap show (Just 42)
logShow $ foldMap show (Nothing :: Maybe Int)
</code></pre>
<p>Expected output:</p>
<pre><code>"42"
unit
""
unit
</code></pre>
</li>
<li>
<p><strong>Fold a Tuple</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Foldable
import Data.Tuple
logShow $ foldMap show (Tuple 1 2)
</code></pre>
<p>Expected output:</p>
<pre><code>"2"
unit
</code></pre>
</li>
</ol>
<h3 id="summary-4"><a class="header" href="#summary-4">Summary</a></h3>
<p>JavaScript’s <code>reduce</code> is array-specific and requires manual handling for other structures like optionals or pairs, with clunky conversions for types like Map. PureScript’s <code>Foldable</code> type class generalizes folding over containers like arrays, <code>Maybe</code>, <code>Tuple</code>, and maps, with type-safe, reusable operations. For JavaScript developers, <code>Foldable</code> simplifies reducing diverse data shapes, reducing custom code and errors in aggregations.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="functor"><a class="header" href="#functor">Functor</a></h2>
<h3 id="javascript-context-mapping-over-structures"><a class="header" href="#javascript-context-mapping-over-structures">JavaScript Context: Mapping Over Structures</a></h3>
<p>In JavaScript, mapping over arrays to transform elements is common with <code>Array.map</code>:</p>
<pre><code class="language-javascript">const numbers = [1, 2, 3];
const doubled = numbers.map(x =&gt; x * 2); // [2, 4, 6]
console.log(doubled);
</code></pre>
<p>For other structures, it's less formalized. For optionals (null/undefined):</p>
<pre><code class="language-javascript">const optionalNumber = 42; // or null
const doubledOptional = optionalNumber !== null ? optionalNumber * 2 : null; // 84 or null
console.log(doubledOptional);
</code></pre>
<p>For promises:</p>
<pre><code class="language-javascript">const promise = Promise.resolve(42);
const doubledPromise = promise.then(x =&gt; x * 2); // resolves to 84
doubledPromise.then(console.log);
</code></pre>
<p>For objects (as maps):</p>
<pre><code class="language-javascript">const obj = { a: 1, b: 2, c: 3 };
const doubledObj = Object.fromEntries(Object.entries(obj).map(([k, v]) =&gt; [k, v * 2])); // { a: 2, b: 4, c: 6 }
console.log(doubledObj);
</code></pre>
<p>This is flexible but ad hoc—you write custom mapping for each type, with no guarantees like identity (mapping x =&gt; x returns original) or composition (mapping f then g equals mapping g ◦ f). Chained maps might break if not handled properly, and there's no type safety for mappable structures.</p>
<p>To show how composition can go wrong, consider a custom map with side effects (like logging):</p>
<pre><code class="language-javascript">let count = 0;
function badMap(f, arr) {
  count++; // Side effect: increment count
  return arr.map(f);
}
const f = x =&gt; x * 2;
const g = x =&gt; x + 1;
const arr = [1, 2, 3];
const left = badMap(f, badMap(g, arr)); // count incremented twice
console.log(left, count); // [4, 6, 8], 2
count = 0; // Reset for next
const right = badMap(x =&gt; f(g(x)), arr); // count incremented once
console.log(right, count); // [4, 6, 8], 1
</code></pre>
<p>The results are the same, but the side effects (count) differ based on grouping, violating composition predictability. In real code, this could cause bugs with shared state or performance issues.</p>
<h3 id="purescripts-functor-a-structured-approach"><a class="header" href="#purescripts-functor-a-structured-approach">PureScript’s <code>Functor</code>: A Structured Approach</a></h3>
<p>PureScript’s <code>Functor</code> type class formalizes mapping over structures, with laws for predictability. It’s defined as:</p>
<pre><code class="language-purescript">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>The <code>map</code> function (alias <code>&lt;$&gt;</code>) lifts a function over the structure. Laws: identity (map id == id) and composition (map (f ◦ g) == map f ◦ map g).</p>
<p>For arrays:</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Array
logShow $ map (\x -&gt; x * 2) [1, 2, 3]
</code></pre>
<p>Expected output:</p>
<pre><code>[2,4,6]
unit
</code></pre>
<p>For <code>Maybe</code>:</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Data.Maybe
logShow $ map (\x -&gt; x * 2) (Just 42)
logShow $ map (\x -&gt; x * 2) Nothing
</code></pre>
<p>Expected output:</p>
<pre><code>(Just 84)
unit
Nothing
unit
</code></pre>
<p>For <code>Tuple</code> (maps second component):</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Data.Tuple
logShow $ map (\x -&gt; x * 2) (Tuple "fixed" 42)
</code></pre>
<p>Expected output:</p>
<pre><code>(Tuple "fixed" 84)
unit
</code></pre>
<p>The compiler ensures <code>Functor</code> instances exist, catching errors at compile time. Laws make mapping reliable—e.g., composition preserves order without side effects.</p>
<h3 id="why-purescripts-functor-is-helpful"><a class="header" href="#why-purescripts-functor-is-helpful">Why PureScript’s <code>Functor</code> Is Helpful</a></h3>
<ol>
<li>
<p><strong>Compile-Time Safety</strong>: In JS, mapping non-mappable types fails at runtime. Functor requires instances, catching errors early.</p>
</li>
<li>
<p><strong>Consistent Mapping</strong>: Uniform <code>map</code> for arrays, <code>Maybe</code>, <code>Tuple</code>, maps— no custom hacks.</p>
</li>
<li>
<p><strong>Laws for Predictability</strong>: Identity and composition ensure mapping behaves as expected, unlike JS where chained maps can surprise (e.g., with side effects).</p>
</li>
</ol>
<h3 id="practical-example-mapping-user-data"><a class="header" href="#practical-example-mapping-user-data">Practical Example: Mapping User Data</a></h3>
<p>Map over optional data (Maybe) or pairs (Tuple) uniformly:</p>
<p>In PSCi:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Maybe
import Data.Tuple
logShow $ map (\s -&gt; s &lt;&gt; " logged in") (Just "user1")
logShow $ map (\s -&gt; s &lt;&gt; " status:") (Tuple "user2" "active")
</code></pre>
<p>Expected output:</p>
<pre><code>(Just "user1 logged in")
unit
(Tuple "user2" "active status:")
unit
</code></pre>
<p>This generalizes mapping, reusable across structures.</p>
<h3 id="repl-exercises-5"><a class="header" href="#repl-exercises-5">REPL Exercises</a></h3>
<p>Try these in a fresh PSCi session (run <code>:clear</code> first). Copy and paste each block:</p>
<ol>
<li>
<p><strong>Map an Array</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Array
logShow $ map (\x -&gt; x * 2) [1, 2, 3]
</code></pre>
<p>Expected output:</p>
<pre><code>[2,4,6]
unit
</code></pre>
</li>
<li>
<p><strong>Map a Maybe</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Maybe
logShow $ map (\x -&gt; x * 2) (Just 42)
logShow $ map (\x -&gt; x * 2) Nothing
</code></pre>
<p>Expected output:</p>
<pre><code>(Just 84)
unit
Nothing
unit
</code></pre>
</li>
<li>
<p><strong>Map a Tuple</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Tuple
logShow $ map (\x -&gt; x * 2) (Tuple "fixed" 42)
</code></pre>
<p>Expected output:</p>
<pre><code>(Tuple "fixed" 84)
unit
</code></pre>
</li>
</ol>
<h3 id="summary-5"><a class="header" href="#summary-5">Summary</a></h3>
<p>JavaScript’s mapping is structure-specific and requires manual handling for optionals or pairs. PureScript’s <code>Functor</code> type class generalizes mapping over containers like arrays, <code>Maybe</code>, <code>Tuple</code>, with type-safe, law-abiding operations. For JavaScript developers, <code>Functor</code> simplifies transforming data in diverse structures, reducing custom code and errors in transformations.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="applicative-functors"><a class="header" href="#applicative-functors">Applicative Functors</a></h2>
<h3 id="javascript-context-validating-and-combining-form-inputs"><a class="header" href="#javascript-context-validating-and-combining-form-inputs">JavaScript Context: Validating and Combining Form Inputs</a></h3>
<p>In JavaScript, you often validate form inputs like first name, last name, and email before combining them into a user object. A common approach is using <code>null</code> checks:</p>
<pre><code class="language-javascript">function createUser(first, last, email) {
  if (first &amp;&amp; last &amp;&amp; email) {
    return { first, last, email };
  }
  return null;
}
console.log(createUser("Phillip", "Freeman", "phil@example.com")); // { first: "Phillip", last: "Freeman", email: "phil@example.com" }
console.log(createUser("Phillip", null, "phil@example.com")); // null
</code></pre>
<p>This is straightforward but limited. To provide better feedback, you might validate each input and return a result with either the user object or errors, wrapping the result in a context:</p>
<pre><code class="language-javascript">function validateInput(value, field) {
  if (!value) return { valid: false, errors: [`${field} is required`] };
  if (field === "email" &amp;&amp; !value.includes("@")) return { valid: false, errors: ["Valid email is required"] };
  return { valid: true, value };
}
function createUserValidated(first, last, email) {
  const firstResult = validateInput(first, "First name");
  const lastResult = validateInput(last, "Last name");
  const emailResult = validateInput(email, "Email");
  if (firstResult.valid &amp;&amp; lastResult.valid &amp;&amp; emailResult.valid) {
    return { valid: true, value: { first: firstResult.value, last: lastResult.value, email: emailResult.value } };
  }
  const errors = [];
  if (!firstResult.valid) errors.push(...firstResult.errors);
  if (!lastResult.valid) errors.push(...lastResult.errors);
  if (!emailResult.valid) errors.push(...emailResult.errors);
  return { valid: false, errors };
}
console.log(createUserValidated("Phillip", "Freeman", "phil@example.com")); 
// { valid: true, value: { first: "Phillip", last: "Freeman", email: "phil@example.com" } }
console.log(createUserValidated("Phillip", null, "invalid")); 
// { valid: false, errors: ["Last name is required", "Valid email is required"] }
</code></pre>
<p>This improved version applies <code>createUser</code> to validated inputs within a context (<code>{ valid, value }</code> or <code>{ errors }</code>), but it’s repetitive. You manually check each result, combine errors, and ensure types match. Extending this to other structures (e.g., arrays or async data) requires more custom code, and there’s no type safety to catch errors early, risking runtime issues if inputs are unexpected types.</p>
<h3 id="purescripts-applicative-structured-function-application"><a class="header" href="#purescripts-applicative-structured-function-application">PureScript’s <code>Applicative</code>: Structured Function Application</a></h3>
<p>PureScript’s <code>Applicative</code> type class builds on <code>Apply</code> (which itself builds on <code>Functor</code>) to apply functions inside containers (like optionals, arrays, or async computations) to values in other containers, with type safety. It’s defined as:</p>
<pre><code class="language-purescript">class Apply f &lt;= Applicative f where
  pure :: forall a. a -&gt; f a
</code></pre>
<p>The <code>Apply</code> type class, a prerequisite for <code>Applicative</code>, provides:</p>
<pre><code class="language-purescript">class Functor f &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<ul>
<li><code>pure</code> wraps a value or function into the container’s context. For example, with <code>Maybe</code>, <code>pure x = Just x</code>; with arrays, <code>pure x = [x]</code>. In Applicatives, <code>pure</code> lifts a regular function (like <code>createUser</code>) into the container (e.g., <code>Just createUser</code> or <code>[createUser]</code>) so it can be applied to wrapped values.</li>
<li><code>apply</code> (alias <code>&lt;*&gt;</code> ) takes a function in a container and applies it to a value in another container of the same type.</li>
</ul>
<p>The <code>pure</code> function is crucial: it takes a plain function, like <code>createUser :: String -&gt; String -&gt; String -&gt; { first :: String, last :: String, email :: String }</code>, and lifts it into the applicative context (e.g., <code>Just createUser</code> for <code>Maybe</code> or <code>[createUser]</code> for arrays). This enables <code>&lt;*&gt;</code> to apply the function to wrapped values, combining their effects (e.g., failing if any <code>Maybe</code> is <code>Nothing</code>, or generating all combinations for arrays).</p>
<p>For example, combining form inputs with <code>Maybe</code> (optional values):</p>
<p>In PSCi, paste (using <code>:paste</code> mode, then <code>Ctrl+D</code>):</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Maybe
createUser first last email = { first, last, email }
logShow $ pure createUser &lt;*&gt; Just "Phillip" &lt;*&gt; Just "Freeman" &lt;*&gt; Just "phil@example.com" 
logShow $ pure createUser &lt;*&gt; Just "Phillip" &lt;*&gt; (Nothing :: Maybe String) &lt;*&gt; Just "phil@example.com" 
</code></pre>
<p>Expected output:</p>
<pre><code>(Just { first: "Phillip", last: "Freeman", email: "phil@example.com" })
unit
Nothing
unit
</code></pre>
<p>For arrays (applying to all combinations):</p>
<p>In PSCi, paste (using <code>:paste</code> mode, then <code>Ctrl+D</code>):</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Array
createUser first last email = { first, last, email }
logShow $ pure createUser &lt;*&gt; ["Phillip", "Phil"] &lt;*&gt; ["Freeman", "Smith"] &lt;*&gt; ["phil@example.com", "psmith@example.com"] 
</code></pre>
<p>Expected output:</p>
<pre><code>[{ first: "Phillip", last: "Freeman", email: "phil@example.com" },{ first: "Phillip", last: "Freeman", email: "psmith@example.com" },{ first: "Phillip", last: "Smith", email: "phil@example.com" },{ first: "Phillip", last: "Smith", email: "psmith@example.com" },{ first: "Phil", last: "Freeman", email: "phil@example.com" },{ first: "Phil", last: "Freeman", email: "psmith@example.com" },{ first: "Phil", last: "Smith", email: "phil@example.com" },{ first: "Phil", last: "Smith", email: "psmith@example.com" }]
unit
</code></pre>
<p>The compiler ensures <code>Applicative</code> instances exist and types match, catching errors at compile time. Applicative laws (identity, composition, homomorphism) ensure predictable behavior, unlike JavaScript’s manual checks.</p>
<h3 id="why-applicative-is-helpful"><a class="header" href="#why-applicative-is-helpful">Why <code>Applicative</code> Is Helpful</a></h3>
<ol>
<li>
<p><strong>Unified Function Application</strong>: Unlike JS’s repetitive <code>null</code> checks, <code>Applicative</code> applies functions in containers (like optionals, arrays, async computations) to values in containers uniformly, without manual conditionals.</p>
</li>
<li>
<p><strong>Type Safety</strong>: Ensures the function and values are compatible before running, avoiding JS runtime errors from missing or mismatched inputs.</p>
</li>
<li>
<p><strong>Reusable Code</strong>: One <code>apply</code> operator works across different structures, reducing custom code compared to JS’s type-specific checks.</p>
</li>
</ol>
<p>The <code>pure</code> function lifts <code>createUser</code> into <code>Maybe</code>, enabling <code>&lt;*&gt;</code> to apply it to optional values, similar to JavaScript’s validated checks but safer and more structured.</p>
<h3 id="repl-exercises-6"><a class="header" href="#repl-exercises-6">REPL Exercises</a></h3>
<p>Try these in a fresh PSCi session (run <code>:clear</code> first). Copy and paste each block using <code>:paste</code> mode (type <code>:paste</code>, paste the code, then press <code>Ctrl+D</code> to execute):</p>
<ol>
<li>
<p><strong>Apply with Maybe</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Maybe
createUser first last email = { first, last, email }
logShow $ pure createUser &lt;*&gt; Just "Phillip" &lt;*&gt; Just "Freeman" &lt;*&gt; Just "phil@example.com"
logShow $ pure createUser &lt;*&gt; Just "Phillip" &lt;*&gt; (Nothing :: Maybe String) &lt;*&gt; Just "phil@example.com" 
</code></pre>
<p>Expected output:</p>
<pre><code>(Just { first: "Phillip", last: "Freeman", email: "phil@example.com" })
unit
Nothing
unit
</code></pre>
</li>
<li>
<p><strong>Apply with Array</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Array
createUser first last email = { first, last, email }
logShow $ pure createUser &lt;*&gt; ["Phillip", "Phil"] &lt;*&gt; ["Freeman", "Smith"] &lt;*&gt; ["phil@example.com", "psmith@example.com"]
</code></pre>
<p>Expected output:</p>
<pre><code>[{ first: "Phillip", last: "Freeman", email: "phil@example.com" },{ first: "Phillip", last: "Freeman", email: "psmith@example.com" },{ first: "Phillip", last: "Smith", email: "phil@example.com" },{ first: "Phillip", last: "Smith", email: "psmith@example.com" },{ first: "Phil", last: "Freeman", email: "phil@example.com" },{ first: "Phil", last: "Freeman", email: "psmith@example.com" },{ first: "Phil", last: "Smith", email: "phil@example.com" },{ first: "Phil", last: "Smith", email: "psmith@example.com" }]
unit
</code></pre>
</li>
<li>
<p><strong>Apply with Custom Type</strong>:</p>
<pre><code class="language-purescript"> import Prelude
 import Effect.Console
 newtype Point a = Point { x :: a, y :: a }
 instance Show a =&gt; Show (Point a) where
   show (Point p) = "(Point " &lt;&gt; show p.x &lt;&gt; " " &lt;&gt; show p.y &lt;&gt; ")"
 instance Functor Point where
   map f (Point p) = Point { x: f p.x, y: f p.y }
 instance Apply Point where
   apply (Point p) (Point q) = Point { x: p.x q.x, y: p.y q.y }
 instance Applicative Point where
   pure x = Point { x: x, y: x }
 logShow $ pure (\n -&gt; n * 2) &lt;*&gt; Point { x: 3, y: 4 } {- - Double coordinates with pure -}
</code></pre>
</li>
</ol>
<p><strong>Explanation</strong>:
This example works because <code>Point</code> is defined with a generic type <code>a</code> (<code>newtype Point a</code>), allowing it to hold any type, including functions like <code>Int -&gt; Int</code>. The <code>Show a =&gt; Show (Point a)</code> instance depends on the <code>Show</code> instance for <code>a</code>, ensuring that the <code>x</code> and <code>y</code> fields (e.g., integers or functions) can be converted to strings for display. This is an instance dependency, similar to how <code>Show (Array a)</code> requires <code>Show a</code>, as seen in Chapter 6. In the expression <code>pure (\n -&gt; n * 2) &lt;*&gt; Point { x: 3, y: 4 }</code>:</p>
<ul>
<li><code>pure (\n -&gt; n * 2)</code> lifts the function <code>\n -&gt; n * 2 :: Int -&gt; Int</code> into <code>Point</code>, creating <code>Point { x: \n -&gt; n * 2, y: \n -&gt; n * 2 } :: Point (Int -&gt; Int)</code>.</li>
<li>The <code>&lt;*&gt;</code> operator (from <code>Apply</code>) applies this <code>Point</code> of functions to <code>Point { x: 3, y: 4 } :: Point Int</code>, producing <code>Point { x: (\n -&gt; n * 2) 3, y: (\n -&gt; n * 2) 4 } = Point { x: 6, y: 8 }</code>.</li>
<li>The <code>Show</code> instance for <code>Point Int</code> relies on <code>Show Int</code> to display <code>(Point 6 8)</code>. This flexibility makes <code>Point</code> a useful example of how Applicatives can work with custom types, mirroring JavaScript’s ability to transform objects but with type safety.</li>
</ul>
<p>Expected output:</p>
<pre><code>(Point 6 8)
unit
</code></pre>
<h3 id="summary-6"><a class="header" href="#summary-6">Summary</a></h3>
<p>JavaScript’s manual validation and <code>null</code> checks for combining form inputs are repetitive and risk runtime errors. PureScript’s <code>Applicative</code> type class, with <code>pure</code> lifting functions into containers like <code>Maybe</code>, arrays, or <code>Aff</code>, provides a type-safe, reusable way to apply functions to values in other containers. For JavaScript developers, <code>Applicative</code> simplifies combining data across diverse structures, catching errors early and reducing custom code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="traversable-functors"><a class="header" href="#traversable-functors">Traversable Functors</a></h2>
<h3 id="javascript-context-validating-arrays-of-data"><a class="header" href="#javascript-context-validating-arrays-of-data">JavaScript Context: Validating Arrays of Data</a></h3>
<p>In JavaScript, you often validate collections of data, like an array of phone numbers, to ensure each element is valid before using it. A common approach is mapping over the array with a validation function and collecting results or errors:</p>
<pre><code class="language-javascript">function validatePhoneNumber(phone) {
  const regex = /^\d{3}-\d{3}-\d{4}$/;
  return regex.test(phone) ? { valid: true, value: phone } : { valid: false, errors: ["Invalid phone format"] };
}
function validatePhones(phones) {
  const results = phones.map(validatePhoneNumber);
  const errors = results.filter(r =&gt; !r.valid).map(r =&gt; r.errors).flat();
  return errors.length ? { valid: false, errors } : { valid: true, value: results.map(r =&gt; r.value) };
}
console.log(validatePhones(["555-555-5555", "555-555-0000"])); 
// { valid: true, value: ["555-555-5555", "555-555-0000"] }
console.log(validatePhones(["555-555-5555", "invalid"])); 
// { valid: false, errors: ["Invalid phone format"] }
</code></pre>
<p><strong>How This Differs from the Applicative Example</strong>: Unlike the Applicative example’s <code>createUserValidated</code>, which validates and combines independent inputs (first name, last name, email) into a single user object, this example iterates over a single array of phone numbers, applying <code>validatePhoneNumber</code> to each element and collecting results or errors while keeping the array structure. The Applicative example lifts a function over multiple validated inputs, whereas this maps a validation function across a collection, preserving its shape. This distinction highlights Traversable’s focus on processing each element in a structure, not combining separate values.</p>
<p>This pattern—mapping a validation function over an array and collecting results or errors—is common in form validation or data processing. However, it’s repetitive and specific to arrays. If you need to validate other structures (like optional values or nested objects), you write custom code for each. There’s no type safety to ensure the validation function and data match, and runtime errors can occur if inputs are unexpected types, like non-strings in the <code>phones</code> array.</p>
<h3 id="purescripts-traversable-structured-iteration-with-effects"><a class="header" href="#purescripts-traversable-structured-iteration-with-effects">PureScript’s <code>Traversable</code>: Structured Iteration with Effects</a></h3>
<p>PureScript’s <code>Traversable</code> type class builds on <code>Functor</code> and <code>Foldable</code> to iterate over a data structure (like arrays, optionals, or custom types), applying an effectful function (e.g., validation) to each element and collecting results in a new structure of the same shape, with type safety. It’s defined as:</p>
<pre><code class="language-purescript">class (Functor t, Foldable t) &lt;= Traversable t where
  traverse :: forall a b m. Applicative m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
  sequence :: forall a m. Applicative m =&gt; t (m a) -&gt; m (t a)
</code></pre>
<ul>
<li><code>traverse</code> applies an effectful function (e.g., <code>a -&gt; m b</code>, where <code>m</code> is an Applicative like <code>V Errors</code>) to each element of a structure <code>t a</code>, producing a new structure <code>m (t b)</code> with combined effects.</li>
<li><code>sequence</code> flips a structure of effectful computations <code>t (m a)</code> into an effectful structure <code>m (t a)</code>.</li>
</ul>
<p>The key idea is that <code>Traversable</code> lets you “walk” a structure, apply a function that produces effects (like validation errors), and collect results while preserving the structure’s shape. For example, <code>traverse</code> can validate an array of phone numbers, producing either a valid array or a collection of errors.</p>
<p>For arrays with validation (using <code>V Errors</code> from <code>purescript-validation</code>):</p>
<p>In PSCi, paste (using <code>:paste</code> mode, then <code>Ctrl+D</code>):</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Array
import Data.Traversable
import Data.Validation.Semigroup
import Data.List.NonEmpty (singleton)
import Data.String.Regex
import Data.String.Regex.Unsafe
import Data.String.Regex.Flags
newtype PhoneNumber = PhoneNumber String
instance Show PhoneNumber where
  show (PhoneNumber s) = "(PhoneNumber " &lt;&gt; show s &lt;&gt; ")"
phoneNumberRegex = unsafeRegex "^\\d{3}-\\d{3}-\\d{4}$" noFlags
validatePhoneNumber s = if test phoneNumberRegex s
  then pure (PhoneNumber s)
  else invalid (singleton "Invalid phone format")
phones = ["555-555-5555", "555-555-0000"]
logShow $ traverse validatePhoneNumber phones {- - Validates each phone number -}
badPhones = ["555-555-5555", "invalid"]
logShow $ traverse validatePhoneNumber badPhones {- - Collects errors -}
</code></pre>
<p>Expected output:</p>
<pre><code>(valid [(PhoneNumber "555-555-5555"),(PhoneNumber "555-555-0000")])
unit
(invalid (["Invalid phone format"]))
unit
</code></pre>
<p>For <code>Maybe</code> (optional values):</p>
<p>In PSCi, paste (using <code>:paste</code> mode, then <code>Ctrl+D</code>):</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console (logShow)
import Data.Maybe (Maybe(..))
import Data.Traversable (traverse)
import Data.List.Types (NonEmptyList(..), List(..))
import Data.Validation.Semigroup (V, invalid)
import Data.NonEmpty (NonEmpty(..), singleton)

nonEmpty field s = 
  if s == "" 
    then invalid (NonEmpty ("Field '" &lt;&gt; field &lt;&gt; "' cannot be empty") Nil)
    else pure s

logShow $ traverse (nonEmpty "Example") Nothing -- No validation for Nothing
logShow $ traverse (nonEmpty "Example") (Just "") -- Validates Just value
logShow $ traverse (nonEmpty "Example") (Just "Testing") -- Successful validation
</code></pre>
<p>Expected output:</p>
<pre><code>(valid Nothing)
unit
(invalid (["Field 'Example' cannot be empty"]))
unit
(valid (Just "Testing"))
unit
</code></pre>
<p>The compiler ensures <code>Traversable</code> instances exist and types match, catching errors at compile time. Traversable laws ensure the structure is preserved and effects are combined predictably, unlike JavaScript’s ad hoc validation.</p>
<h3 id="why-traversable-is-helpful"><a class="header" href="#why-traversable-is-helpful">Why <code>Traversable</code> Is Helpful</a></h3>
<ol>
<li>
<p><strong>Unified Iteration with Effects</strong>: Unlike JS’s array-specific validation loops, <code>Traversable</code> works across structures (arrays, <code>Maybe</code>, custom types), applying effectful functions uniformly.</p>
</li>
<li>
<p><strong>Type Safety</strong>: Ensures the validation function and structure are compatible, avoiding JS runtime errors from mismatched types.</p>
</li>
<li>
<p><strong>Reusable Code</strong>: One <code>traverse</code> function handles various structures, reducing custom code compared to JS’s structure-specific loops.</p>
</li>
</ol>
<h3 id="practical-example-validating-a-list-of-names"><a class="header" href="#practical-example-validating-a-list-of-names">Practical Example: Validating a List of Names</a></h3>
<p>Validate an array of names using <code>traverse</code>:</p>
<p>In PSCi, paste (using <code>:paste</code> mode, then <code>Ctrl+D</code>):</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console (logShow)
import Data.Array
import Data.Traversable (traverse)
import Data.List.Types (NonEmptyList(..), List(..))
import Data.Validation.Semigroup (V, invalid)
import Data.NonEmpty (NonEmpty(..), singleton)
nonEmpty field s = if s == ""
  then invalid (NonEmpty ("Field '" &lt;&gt; field &lt;&gt; "' cannot be empty") Nil)
  else pure s
logShow $ traverse (nonEmpty "Name") ["Phillip", "Freeman"] {- - Validates each name -}
logShow $ traverse (nonEmpty "Name") ["Phillip", ""] {- - Collects errors -}
</code></pre>
<p>Expected output:</p>
<pre><code>(valid ["Phillip","Freeman"])
unit
(invalid (["Field 'Name' cannot be empty"]))
unit
</code></pre>
<p>This generalizes validation across structures, similar to JavaScript’s array validation but safer and more flexible.</p>
<h3 id="repl-exercises-7"><a class="header" href="#repl-exercises-7">REPL Exercises</a></h3>
<p>Try these in a fresh PSCi session (run <code>:clear</code> first). Copy and paste each block using <code>:paste</code> mode (type <code>:paste</code>, paste the code, then press <code>Ctrl+D</code> to execute):</p>
<ol>
<li>
<p><strong>Traverse with Array</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console (logShow)
import Data.Array
import Data.Traversable (traverse)
import Data.List.Types (NonEmptyList(..), List(..))
import Data.Validation.Semigroup (V, invalid)
import Data.NonEmpty (NonEmpty(..), singleton)
nonEmpty field s = if s == ""
  then invalid (NonEmpty ("Field '" &lt;&gt; field &lt;&gt; "' cannot be empty") Nil)
  else pure s
logShow $ traverse (nonEmpty "Name") ["Phillip", "Freeman"] {- - Validate names in array -}
logShow $ traverse (nonEmpty "Name") ["Phillip", ""] {- - Collect errors -}
</code></pre>
<p>Expected output:</p>
<pre><code>(valid ["Phillip","Freeman"])
unit
(invalid (["Field 'Name' cannot be empty"]))
unit
</code></pre>
</li>
<li>
<p><strong>Traverse with Maybe</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console (logShow)
import Data.Maybe (Maybe(..))
import Data.Traversable (traverse)
import Data.List.Types (NonEmptyList(..), List(..))
import Data.Validation.Semigroup (V, invalid)
import Data.NonEmpty (NonEmpty(..), singleton)
nonEmpty field s = if s == ""
  then invalid (NonEmpty ("Field '" &lt;&gt; field &lt;&gt; "' cannot be empty") Nil)
  else pure s
logShow $ traverse (nonEmpty "Example") Nothing {- - No validation for Nothing -}
logShow $ traverse (nonEmpty "Example") (Just "") {- - Validate Just value -}
logShow $ traverse (nonEmpty "Example") (Just "Testing") {- - Successful validation -}
</code></pre>
<p>Expected output:</p>
<pre><code>(valid Nothing)
unit
(invalid (["Field 'Example' cannot be empty"]))
unit
(valid (Just "Testing"))
unit
</code></pre>
</li>
</ol>
<h3 id="summary-7"><a class="header" href="#summary-7">Summary</a></h3>
<p>JavaScript’s array validation loops, like <code>validatePhones</code>, are repetitive, array-specific, and risk runtime errors. PureScript’s <code>Traversable</code> type class provides a type-safe, reusable way to apply effectful functions (like validation) across structures like arrays, <code>Maybe</code>, or custom types, preserving their shape while combining effects. Unlike Applicative functors, which combine independent effectful values (like form fields in <code>createUserValidated</code>), Traversables iterate over a single structure’s elements, making them ideal for validating collections. For JavaScript developers, <code>Traversable</code> simplifies validating data in diverse structures, catching errors early and reducing custom code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="monads"><a class="header" href="#monads">Monads</a></h2>
<h3 id="javascript-context-chaining-asynchronous-operations"><a class="header" href="#javascript-context-chaining-asynchronous-operations">JavaScript Context: Chaining Asynchronous Operations</a></h3>
<p>In JavaScript, you often chain asynchronous operations, like fetching user data and then retrieving related information, using Promises to handle the sequence. For example, suppose you want to fetch a user’s profile, then their address, and finally their city:</p>
<pre><code class="language-javascript">function fetchUser(userId) {
  return Promise.resolve({ id: userId, profileId: `profile-${userId}` });
}
function fetchProfile(profileId) {
  return Promise.resolve({ profileId, addressId: `address-${profileId}` });
}
function fetchCity(addressId) {
  return Promise.resolve({ addressId, city: "Faketown" });
}
fetchUser(123)
  .then(user =&gt; fetchProfile(user.profileId))
  .then(profile =&gt; fetchCity(profile.addressId))
  .then(address =&gt; ({ city: address.city }))
  .then(console.log); // { city: "Faketown" }
fetchUser(null)
  .then(user =&gt; fetchProfile(user.profileId))
  .then(profile =&gt; fetchCity(profile.addressId))
  .then(address =&gt; ({ city: address.city }))
  .catch(error =&gt; console.log({ error: error.message })); // { error: "Cannot read properties of null" }
</code></pre>
<p>This pattern—chaining operations where each step depends on the previous result—is common in JavaScript for handling async tasks like API calls or database queries. You use <code>.then</code> to sequence the operations, passing the result of one to the next. However, it’s error-prone: if any step fails (e.g., <code>user</code> is <code>null</code>), you get runtime errors, and you need <code>.catch</code> to handle failures. Extending this to other contexts (like optional values or arrays) requires custom code, and there’s no type safety to ensure each step’s output matches the next step’s input.</p>
<h3 id="purescripts-monad-structured-sequential-computations"><a class="header" href="#purescripts-monad-structured-sequential-computations">PureScript’s <code>Monad</code>: Structured Sequential Computations</a></h3>
<p>PureScript’s <code>Monad</code> type class formalizes this pattern of chaining dependent computations, allowing you to sequence operations where each step uses the result of the previous one, with type safety. It builds on <code>Applicative</code> and <code>Apply</code> (from Chapter 7) and is defined as:</p>
<pre><code class="language-purescript">class Apply m &lt;= Bind m where
  bind :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b

class (Applicative m, Bind m) &lt;= Monad m
</code></pre>
<ul>
<li><code>bind</code> (alias <code>&gt;&gt;=</code>) takes a computation in a context <code>m a</code> (e.g., <code>Maybe a</code>, <code>Aff a</code>) and a function that produces the next computation <code>(a -&gt; m b)</code>, chaining them to produce a final <code>m b</code>.</li>
<li><code>pure</code> (from <code>Applicative</code>) wraps a value into the context, and <code>&lt;*&gt;</code> (from <code>Apply</code>) applies functions within the context.</li>
</ul>
<p>The <code>do</code> notation simplifies writing these chained computations, making them look sequential like JavaScript’s <code>.then</code> chains. For example, with <code>Maybe</code> (optional values):</p>
<p>In PSCi, paste (using <code>:paste</code> mode, then <code>Ctrl+D</code>):</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Map as Map
import Data.Maybe
import Data.Tuple

lookupUser userId users = Map.lookup userId users
lookupProfile profileId profiles = Map.lookup profileId profiles
lookupCity addressId addresses = Map.lookup addressId addresses

userCity userId users profiles addresses = do
  user &lt;- lookupUser userId users {- - Look up user by ID -}
  profile &lt;- lookupProfile user.profileId profiles {- - Look up profile by profileId -}
  address &lt;- lookupCity profile.addressId addresses {- - Look up address by addressId -}
  pure address.city {- - Return the city -}

users = Map.fromFoldable [ Tuple "user123" { userId: "user123", profileId: "profile-123" } ]
profiles = Map.fromFoldable [ Tuple "profile-123" { profileId: "profile-123", addressId: "address-123" } ]
addresses = Map.fromFoldable [ Tuple "address-123" { addressId: "address-123", city: "Faketown" } ]

logShow $ userCity "user123" users profiles addresses 
logShow $ userCity "wrong" users profiles addresses 
</code></pre>
<p>Expected output:</p>
<pre><code>(Just "Faketown")
unit
Nothing
unit
</code></pre>
<p>This mirrors the JavaScript Promise chain, but <code>Maybe</code> handles missing values safely. The <code>do</code> notation desugars to <code>&gt;&gt;=</code>:</p>
<pre><code class="language-purescript">userCity userId users profiles addresses =
  lookupUser userId users &gt;&gt;= \user -&gt;
    lookupProfile user.profileId profiles &gt;&gt;= \profile -&gt;
      lookupCity profile.addressId addresses &gt;&gt;= \address -&gt;
        pure address.city
</code></pre>
<p>For arrays (non-deterministic computations):</p>
<p>In PSCi, paste (using <code>:paste</code> mode, then <code>Ctrl+D</code>):</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Array
import Control.Plus
countThrows n = do
  x &lt;- [1, 2, 3, 4, 5, 6]
  y &lt;- [1, 2, 3, 4, 5, 6]
  if x + y == n
    then pure [x, y]
    else empty 
logShow $ countThrows 10 {- - Finds all dice throws summing to 10 -}

</code></pre>
<p>Expected output:</p>
<pre><code>[[4,6],[5,5],[6,4]]
unit
</code></pre>
<p>The compiler ensures <code>Monad</code> instances exist and types match, catching errors at compile time. Monad laws (identity, associativity) ensure predictable behavior, unlike JavaScript’s error-prone Promise chains.</p>
<h3 id="why-monad-is-helpful"><a class="header" href="#why-monad-is-helpful">Why <code>Monad</code> Is Helpful</a></h3>
<ol>
<li><strong>Structured Sequential Computations</strong>: Unlike JS’s <code>.then</code> chains, <code>Monad</code> sequences dependent computations across contexts (like optionals, arrays, async) uniformly using <code>do</code> notation.</li>
<li><strong>Type Safety</strong>: Ensures each step’s output matches the next step’s input, avoiding JS runtime errors from nulls or type mismatches.</li>
<li><strong>Reusable Code</strong>: One <code>bind</code> operator (or <code>do</code> notation) works across different structures, reducing custom code compared to JS’s context-specific chaining.</li>
</ol>
<h3 id="practical-example-navigating-a-deeply-nested-map"><a class="header" href="#practical-example-navigating-a-deeply-nested-map">Practical Example: Navigating a deeply-nested map</a></h3>
<p>In PSCi, paste (using <code>:paste</code> mode, then <code>Ctrl+D</code>):</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Map as Map
import Data.Maybe
import Data.Tuple

lookupUser userId users = Map.lookup userId users
lookupProfile profileId profiles = Map.lookup profileId profiles
lookupCity addressId addresses = Map.lookup addressId addresses

userCity userId users profiles addresses = do
  user &lt;- lookupUser userId users {- - Look up user by ID -}
  profile &lt;- lookupProfile user.profileId profiles {- - Look up profile by profileId -}
  address &lt;- lookupCity profile.addressId addresses {- - Look up address by addressId -}
  pure address.city {- - Return the city -}

users = Map.fromFoldable [ Tuple "user123" { userId: "user123", profileId: "profile-123" } ]
profiles = Map.fromFoldable [ Tuple "profile-123" { profileId: "profile-123", addressId: "address-123" } ]
addresses = Map.fromFoldable [ Tuple "address-123" { addressId: "address-123", city: "Faketown" } ]

logShow $ userCity "user123" users profiles addresses 
logShow $ userCity "wrong" users profiles addresses 
</code></pre>
<p>Expected output:</p>
<pre><code>(Just "Faketown")
unit
Nothing
unit
</code></pre>
<p>This mirrors JavaScript’s Promise chaining but is safer and more generalizable.</p>
<h3 id="repl-exercises-8"><a class="header" href="#repl-exercises-8">REPL Exercises</a></h3>
<p>Try these in a fresh PSCi session (run <code>:clear</code> first). Copy and paste each block using <code>:paste</code> mode (type <code>:paste</code>, paste, then press <code>Ctrl+D</code> to execute):</p>
<ol>
<li>
<p><strong>Monad with Maybe</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Map as Map
import Data.Maybe
import Data.Tuple

lookupUser userId users = Map.lookup userId users
lookupProfile profileId profiles = Map.lookup profileId profiles
lookupCity addressId addresses = Map.lookup addressId addresses

userCity userId users profiles addresses = do
  user &lt;- lookupUser userId users {- - Look up user by ID -}
  profile &lt;- lookupProfile user.profileId profiles {- - Look up profile by profileId -}
  address &lt;- lookupCity profile.addressId addresses {- - Look up address by addressId -}
  pure address.city {- - Return the city -}

users = Map.fromFoldable [ Tuple "user123" { userId: "user123", profileId: "profile-123" } ]
profiles = Map.fromFoldable [ Tuple "profile-123" { profileId: "profile-123", addressId: "address-123" } ]
addresses = Map.fromFoldable [ Tuple "address-123" { addressId: "address-123", city: "Faketown" } ]

logShow $ userCity "user123" users profiles addresses 
logShow $ userCity "wrong" users profiles addresses 
</code></pre>
<p>Expected output:</p>
<pre><code>(Just "Faketown")
unit
Nothing
unit
</code></pre>
</li>
<li>
<p><strong>Monad with Array</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Array
import Control.Plus
countThrows n = do
x &lt;- [1, 2, 3, 4, 5, 6]
y &lt;- [1, 2, 3, 4, 5, 6]
if x + y == n
then pure [x, y]
else empty 
logShow $ countThrows 10 {- - Finds all dice throws summing to 10 -}
</code></pre>
<p>Expected output:</p>
<pre><code>[[4,6],[5,5],[6,4]]
unit
</code></pre>
</li>
<li>
<p><strong>Monad with Sequential Array Sum</strong>:</p>
<pre><code class="language-purescript">import Prelude
import Effect.Console
import Data.Maybe
import Data.Array
validateNumber n = if n &gt;= 0
  then Just n
  else Nothing {- - Validates non-negative numbers -}
sequentialSum numbers = do
  first &lt;- validateNumber (head numbers # fromMaybe 0) {- - Get first number -}
  rest &lt;- Just (drop 1 numbers) {- - Get remaining numbers -}
  sumRest &lt;- if null rest
    then Just 0
    else sequentialSum rest {- - Recursively sum rest, depends on first -}
  pure (first + sumRest) {- - Combine first with sum of rest -}
logShow $ sequentialSum [1, 2, 3] {- - Successful sum -}
logShow $ sequentialSum [1, -2, 3] {- - Fails if any number invalid -}
logShow $ sequentialSum [] {- - Handles empty array -}
</code></pre>
<p><strong>Explanation</strong>:
This example demonstrates monadic dependency by computing the sum of an array sequentially, where each step validates and processes elements, depending on prior results. The <code>sequentialSum</code> function uses <code>Maybe</code> to handle invalid numbers (e.g., negative). It extracts the first number with <code>validateNumber</code>, gets the remaining numbers, recursively sums the rest (depending on the first number being valid), and combines the results. If any number is invalid or the array is empty, it handles the case safely. This mirrors JavaScript’s sequential reduction with Promises or callbacks, where each step depends on the previous sum, but with type safety.
Expected output:</p>
<pre><code>(Just 6)
unit
Nothing
unit
(Just 0)
unit
</code></pre>
</li>
</ol>
<h3 id="summary-8"><a class="header" href="#summary-8">Summary</a></h3>
<p>JavaScript’s Promise chains, like fetching sequential data, are error-prone and context-specific. PureScript’s <code>Monad</code> type class, with <code>bind</code> and <code>do</code> notation, provides a type-safe, reusable way to chain dependent computations across contexts like <code>Maybe</code>, arrays, or <code>Aff</code>. It formalizes JavaScript’s chaining patterns (e.g., <code>.then</code> or callbacks) without exceeding the complexity of modern web development. For JavaScript developers, <code>Monad</code> simplifies sequential tasks, catching errors early and reducing custom code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="whats-next"><a class="header" href="#whats-next">What's Next</a></h2>
<p>Congratulations on working through <strong>PureScript for JavaScript Developers</strong>! You’ve explored key type classes from Chapters 6–8 of <em>PureScript by Example</em>, connecting familiar JavaScript patterns—like string conversion, equality checks, array operations, form validation, and Promise chaining—to PureScript’s structured, type-safe abstractions. By now, you should feel confident recognizing how <code>Show</code>, <code>Eq</code>, <code>Ord</code>, <code>Semigroup</code>, <code>Monoid</code>, <code>Functor</code>, <code>Foldable</code>, <code>Applicative</code>, <code>Traversable</code>, and <code>Monad</code> formalize JavaScript’s informal practices, making your code more reliable without exceeding the complexity of modern web development.</p>
<h3 id="make-a-financial-contribution"><a class="header" href="#make-a-financial-contribution">Make A Financial Contribution</a></h3>
<p>If this booklet has helped you bridge JavaScript and PureScript, please consider <a href="https://github.com/sponsors/nathan-tranquilla">making a donation</a>.</p>
<h3 id="where-to-go-from-here"><a class="header" href="#where-to-go-from-here">Where to Go from Here</a></h3>
<p>This booklet has prepared you to dive deeper into PureScript by bridging JavaScript’s dynamic patterns with PureScript’s type-safe type classes. To build on this foundation, we recommend returning to <em>PureScript by Example</em> and picking up with the <code>Effect</code> and <code>Aff</code> monads in Chapter 8 and beyond:</p>
<ul>
<li><strong>Effect Monad</strong>: The <code>Effect</code> monad handles native side effects like console logging, DOM manipulation, or random number generation—tasks you’re familiar with from JavaScript functions like <code>console.log</code> or <code>Math.random</code>. Chapter 8 of <em>PureScript by Example</em> explores how <code>Effect</code> encapsulates these side effects safely, offering a structured alternative to JavaScript’s ad hoc approach. Try the exercises to see how <code>Effect</code> integrates with real-world applications, like building interactive web interfaces.</li>
<li><strong>Aff Monad</strong>: The <code>Aff</code> monad manages asynchronous computations, similar to JavaScript’s Promises or <code>async/await</code>. It’s a natural extension of the <code>Monad</code> concepts you’ve learned, providing type-safe ways to handle API calls, timeouts, or other async tasks. Continue with <em>PureScript by Example</em>’s examples and exercises in later chapters to apply <code>Aff</code> in practical scenarios, such as fetching data or handling user input.</li>
</ul>
<h3 id="how-to-proceed"><a class="header" href="#how-to-proceed">How to Proceed</a></h3>
<ol>
<li><strong>Explore Chapter 8’s Effect and Aff Sections</strong>: Dive into the <code>Effect</code> and <code>Aff</code> sections of Chapter 8 to see how PureScript handles side effects and async operations. Experiment with the provided examples in <code>spago repl</code> or a PureScript project to build familiarity.</li>
<li><strong>Continue with Chapter 9 and Beyond</strong>: <em>PureScript by Example</em>’s later chapters introduce advanced topics like monad transformers and real-world applications. These build on the type class foundation you’ve gained, showing how PureScript powers robust web applications.</li>
<li><strong>Apply to Your Projects</strong>: Try using PureScript’s type classes in small projects, like validating forms or processing data, to see how they improve on JavaScript’s patterns. Compare your PureScript solutions to JavaScript equivalents to appreciate the type safety and clarity.</li>
</ol>
<h3 id="why-continue"><a class="header" href="#why-continue">Why Continue?</a></h3>
<p>The concepts you’ve learned—type classes for polymorphism, data combination, mapping, validation, and chaining—are the backbone of PureScript’s power. By exploring <code>Effect</code> and <code>Aff</code>, you’ll see how PureScript manages real-world side effects, making it a practical tool for modern web development. These monads are direct analogs to JavaScript’s side-effecting functions and async workflows, so you’ll find them intuitive yet more robust.</p>
<p>Keep experimenting in the REPL, tackle the exercises in <em>PureScript by Example</em>, and start building with PureScript to bring type safety to your JavaScript expertise. You’re well on your way to writing reliable, maintainable code with PureScript’s elegant abstractions!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
